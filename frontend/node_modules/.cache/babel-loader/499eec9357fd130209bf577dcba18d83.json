{"ast":null,"code":"/*\n UriTemplates Template Processor - Version: @VERSION - Dated: @DATE\n (c) marc.portier@gmail.com - 2011-2012\n Licensed under APLv2 (http://opensource.org/licenses/Apache-2.0)\n */\n;\n\nvar uritemplate = function () {\n  // Below are the functions we originally used from jQuery.\n  // The implementations below are often more naive then what is inside jquery, but they suffice for our needs.\n  function isFunction(fn) {\n    return typeof fn == 'function';\n  }\n\n  function isEmptyObject(obj) {\n    for (var name in obj) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function extend(base, newprops) {\n    for (var name in newprops) {\n      base[name] = newprops[name];\n    }\n\n    return base;\n  }\n  /**\n   * Create a runtime cache around retrieved values from the context.\n   * This allows for dynamic (function) results to be kept the same for multiple\n   * occuring expansions within one template.\n   * Note: Uses key-value tupples to be able to cache null values as well.\n   */\n  //TODO move this into prep-processing\n\n\n  function CachingContext(context) {\n    this.raw = context;\n    this.cache = {};\n  }\n\n  CachingContext.prototype.get = function (key) {\n    var val = this.lookupRaw(key);\n    var result = val;\n\n    if (isFunction(val)) {\n      // check function-result-cache\n      var tupple = this.cache[key];\n\n      if (tupple !== null && tupple !== undefined) {\n        result = tupple.val;\n      } else {\n        result = val(this.raw);\n        this.cache[key] = {\n          key: key,\n          val: result\n        }; // NOTE: by storing tupples we make sure a null return is validly consistent too in expansions\n      }\n    }\n\n    return result;\n  };\n\n  CachingContext.prototype.lookupRaw = function (key) {\n    return CachingContext.lookup(this, this.raw, key);\n  };\n\n  CachingContext.lookup = function (me, context, key) {\n    var result = context[key];\n\n    if (result !== undefined) {\n      return result;\n    } else {\n      var keyparts = key.split('.');\n      var i = 0,\n          keysplits = keyparts.length - 1;\n\n      for (i = 0; i < keysplits; i++) {\n        var leadKey = keyparts.slice(0, keysplits - i).join('.');\n        var trailKey = keyparts.slice(-i - 1).join('.');\n        var leadContext = context[leadKey];\n\n        if (leadContext !== undefined) {\n          return CachingContext.lookup(me, leadContext, trailKey);\n        }\n      }\n\n      return undefined;\n    }\n  };\n\n  function UriTemplate(set) {\n    this.set = set;\n  }\n\n  UriTemplate.prototype.expand = function (context) {\n    var cache = new CachingContext(context);\n    var res = \"\";\n    var i = 0,\n        cnt = this.set.length;\n\n    for (i = 0; i < cnt; i++) {\n      res += this.set[i].expand(cache);\n    }\n\n    return res;\n  }; //TODO: change since draft-0.6 about characters in literals\n\n  /* extract:\n   The characters outside of expressions in a URI Template string are intended to be copied literally to the URI-reference if the character is allowed in a URI (reserved / unreserved / pct-encoded) or, if not allowed, copied to the URI-reference in its UTF-8 pct-encoded form.\n   */\n\n\n  function Literal(txt) {\n    this.txt = txt;\n  }\n\n  Literal.prototype.expand = function () {\n    return this.txt;\n  };\n\n  var RESERVEDCHARS_RE = new RegExp(\"[:/?#\\\\[\\\\]@!$&()*+,;=']\", \"g\");\n\n  function encodeNormal(val) {\n    return encodeURIComponent(val).replace(RESERVEDCHARS_RE, function (s) {\n      return escape(s);\n    });\n  } //var SELECTEDCHARS_RE = new RegExp(\"[]\",\"g\");\n\n\n  function encodeReserved(val) {\n    //return encodeURI(val).replace(SELECTEDCHARS_RE, function(s) {return escape(s)} );\n    return encodeURI(val); // no need for additional replace if selected-chars is empty\n  }\n\n  function addUnNamed(name, key, val) {\n    return key + (key.length > 0 ? \"=\" : \"\") + val;\n  }\n\n  function addNamed(name, key, val, noName) {\n    noName = noName || false;\n\n    if (noName) {\n      name = \"\";\n    }\n\n    if (!key || key.length === 0) {\n      key = name;\n    }\n\n    return key + (key.length > 0 ? \"=\" : \"\") + val;\n  }\n\n  function addLabeled(name, key, val, noName) {\n    noName = noName || false;\n\n    if (noName) {\n      name = \"\";\n    }\n\n    if (!key || key.length === 0) {\n      key = name;\n    }\n\n    return key + (key.length > 0 && val ? \"=\" : \"\") + val;\n  }\n\n  var simpleConf = {\n    prefix: \"\",\n    joiner: \",\",\n    encode: encodeNormal,\n    builder: addUnNamed\n  };\n  var reservedConf = {\n    prefix: \"\",\n    joiner: \",\",\n    encode: encodeReserved,\n    builder: addUnNamed\n  };\n  var fragmentConf = {\n    prefix: \"#\",\n    joiner: \",\",\n    encode: encodeReserved,\n    builder: addUnNamed\n  };\n  var pathParamConf = {\n    prefix: \";\",\n    joiner: \";\",\n    encode: encodeNormal,\n    builder: addLabeled\n  };\n  var formParamConf = {\n    prefix: \"?\",\n    joiner: \"&\",\n    encode: encodeNormal,\n    builder: addNamed\n  };\n  var formContinueConf = {\n    prefix: \"&\",\n    joiner: \"&\",\n    encode: encodeNormal,\n    builder: addNamed\n  };\n  var pathHierarchyConf = {\n    prefix: \"/\",\n    joiner: \"/\",\n    encode: encodeNormal,\n    builder: addUnNamed\n  };\n  var labelConf = {\n    prefix: \".\",\n    joiner: \".\",\n    encode: encodeNormal,\n    builder: addUnNamed\n  };\n\n  function Expression(conf, vars) {\n    extend(this, conf);\n    this.vars = vars;\n  }\n\n  Expression.build = function (ops, vars) {\n    var conf;\n\n    switch (ops) {\n      case '':\n        conf = simpleConf;\n        break;\n\n      case '+':\n        conf = reservedConf;\n        break;\n\n      case '#':\n        conf = fragmentConf;\n        break;\n\n      case ';':\n        conf = pathParamConf;\n        break;\n\n      case '?':\n        conf = formParamConf;\n        break;\n\n      case '&':\n        conf = formContinueConf;\n        break;\n\n      case '/':\n        conf = pathHierarchyConf;\n        break;\n\n      case '.':\n        conf = labelConf;\n        break;\n\n      default:\n        throw \"Unexpected operator: '\" + ops + \"'\";\n    }\n\n    return new Expression(conf, vars);\n  };\n\n  Expression.prototype.expand = function (context) {\n    var joiner = this.prefix;\n    var nextjoiner = this.joiner;\n    var buildSegment = this.builder;\n    var res = \"\";\n    var i = 0,\n        cnt = this.vars.length;\n\n    for (i = 0; i < cnt; i++) {\n      var varspec = this.vars[i];\n      varspec.addValues(context, this.encode, function (key, val, noName) {\n        var segm = buildSegment(varspec.name, key, val, noName);\n\n        if (segm !== null && segm !== undefined) {\n          res += joiner + segm;\n          joiner = nextjoiner;\n        }\n      });\n    }\n\n    return res;\n  };\n\n  var UNBOUND = {};\n  /**\n   * Helper class to help grow a string of (possibly encoded) parts until limit is reached\n   */\n\n  function Buffer(limit) {\n    this.str = \"\";\n\n    if (limit === UNBOUND) {\n      this.appender = Buffer.UnboundAppend;\n    } else {\n      this.len = 0;\n      this.limit = limit;\n      this.appender = Buffer.BoundAppend;\n    }\n  }\n\n  Buffer.prototype.append = function (part, encoder) {\n    return this.appender(this, part, encoder);\n  };\n\n  Buffer.UnboundAppend = function (me, part, encoder) {\n    part = encoder ? encoder(part) : part;\n    me.str += part;\n    return me;\n  };\n\n  Buffer.BoundAppend = function (me, part, encoder) {\n    part = part.substring(0, me.limit - me.len);\n    me.len += part.length;\n    part = encoder ? encoder(part) : part;\n    me.str += part;\n    return me;\n  };\n\n  function arrayToString(arr, encoder, maxLength) {\n    var buffer = new Buffer(maxLength);\n    var joiner = \"\";\n    var i = 0,\n        cnt = arr.length;\n\n    for (i = 0; i < cnt; i++) {\n      if (arr[i] !== null && arr[i] !== undefined) {\n        buffer.append(joiner).append(arr[i], encoder);\n        joiner = \",\";\n      }\n    }\n\n    return buffer.str;\n  }\n\n  function objectToString(obj, encoder, maxLength) {\n    var buffer = new Buffer(maxLength);\n    var joiner = \"\";\n    var k;\n\n    for (k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        if (obj[k] !== null && obj[k] !== undefined) {\n          buffer.append(joiner + k + ',').append(obj[k], encoder);\n          joiner = \",\";\n        }\n      }\n    }\n\n    return buffer.str;\n  }\n\n  function simpleValueHandler(me, val, valprops, encoder, adder) {\n    var result;\n\n    if (valprops.isArr) {\n      result = arrayToString(val, encoder, me.maxLength);\n    } else if (valprops.isObj) {\n      result = objectToString(val, encoder, me.maxLength);\n    } else {\n      var buffer = new Buffer(me.maxLength);\n      result = buffer.append(val, encoder).str;\n    }\n\n    adder(\"\", result);\n  }\n\n  function explodeValueHandler(me, val, valprops, encoder, adder) {\n    if (valprops.isArr) {\n      var i = 0,\n          cnt = val.length;\n\n      for (i = 0; i < cnt; i++) {\n        adder(\"\", encoder(val[i]));\n      }\n    } else if (valprops.isObj) {\n      var k;\n\n      for (k in val) {\n        if (val.hasOwnProperty(k)) {\n          adder(k, encoder(val[k]));\n        }\n      }\n    } else {\n      // explode-requested, but single value\n      adder(\"\", encoder(val));\n    }\n  }\n\n  function valueProperties(val) {\n    var isArr = false;\n    var isObj = false;\n    var isUndef = true; //note: \"\" is empty but not undef\n\n    if (val !== null && val !== undefined) {\n      isArr = val.constructor === Array;\n      isObj = val.constructor === Object;\n      isUndef = isArr && val.length === 0 || isObj && isEmptyObject(val);\n    }\n\n    return {\n      isArr: isArr,\n      isObj: isObj,\n      isUndef: isUndef\n    };\n  }\n\n  function VarSpec(name, vhfn, nums) {\n    this.name = unescape(name);\n    this.valueHandler = vhfn;\n    this.maxLength = nums;\n  }\n\n  VarSpec.build = function (name, expl, part, nums) {\n    var valueHandler, valueModifier;\n\n    if (!!expl) {\n      //interprete as boolean\n      valueHandler = explodeValueHandler;\n    } else {\n      valueHandler = simpleValueHandler;\n    }\n\n    if (!part) {\n      nums = UNBOUND;\n    }\n\n    return new VarSpec(name, valueHandler, nums);\n  };\n\n  VarSpec.prototype.addValues = function (context, encoder, adder) {\n    var val = context.get(this.name);\n    var valprops = valueProperties(val);\n\n    if (valprops.isUndef) {\n      return;\n    } // ignore empty values\n\n\n    this.valueHandler(this, val, valprops, encoder, adder);\n  }; //----------------------------------------------parsing logic\n  // How each varspec should look like\n\n\n  var VARSPEC_RE = /([^*:]*)((\\*)|(:)([0-9]+))?/;\n\n  var match2varspec = function (m) {\n    var name = m[1];\n    var expl = m[3];\n    var part = m[4];\n    var nums = parseInt(m[5], 10);\n    return VarSpec.build(name, expl, part, nums);\n  }; // Splitting varspecs in list with:\n\n\n  var LISTSEP = \",\"; // How each template should look like\n\n  var TEMPL_RE = /(\\{([+#.;?&\\/])?(([^.*:,{}|@!=$()][^*:,{}$()]*)(\\*|:([0-9]+))?(,([^.*:,{}][^*:,{}]*)(\\*|:([0-9]+))?)*)\\})/g; // Note: reserved operators: |!@ are left out of the regexp in order to make those templates degrade into literals\n  // (as expected by the spec - see tests.html \"reserved operators\")\n\n  var match2expression = function (m) {\n    var expr = m[0];\n    var ops = m[2] || '';\n    var vars = m[3].split(LISTSEP);\n    var i = 0,\n        len = vars.length;\n\n    for (i = 0; i < len; i++) {\n      var match;\n\n      if ((match = vars[i].match(VARSPEC_RE)) === null) {\n        throw \"unexpected parse error in varspec: \" + vars[i];\n      }\n\n      vars[i] = match2varspec(match);\n    }\n\n    return Expression.build(ops, vars);\n  };\n\n  var pushLiteralSubstr = function (set, src, from, to) {\n    if (from < to) {\n      var literal = src.substr(from, to - from);\n      set.push(new Literal(literal));\n    }\n  };\n\n  var parse = function (str) {\n    var lastpos = 0;\n    var comp = [];\n    var match;\n    var pattern = TEMPL_RE;\n    pattern.lastIndex = 0; // just to be sure\n\n    while ((match = pattern.exec(str)) !== null) {\n      var newpos = match.index;\n      pushLiteralSubstr(comp, str, lastpos, newpos);\n      comp.push(match2expression(match));\n      lastpos = pattern.lastIndex;\n    }\n\n    pushLiteralSubstr(comp, str, lastpos, str.length);\n    return new UriTemplate(comp);\n  }; //-------------------------------------------comments and ideas\n  //TODO: consider building cache of previously parsed uris or even parsed expressions?\n\n\n  return parse;\n}();","map":{"version":3,"sources":["/Users/fkhw/CourseWorks/Cloud Computing & Big Data/homework2/front/photo-search/src/lib/url-template/url-template.js"],"names":["uritemplate","isFunction","fn","isEmptyObject","obj","name","extend","base","newprops","CachingContext","context","raw","cache","prototype","get","key","val","lookupRaw","result","tupple","undefined","lookup","me","keyparts","split","i","keysplits","length","leadKey","slice","join","trailKey","leadContext","UriTemplate","set","expand","res","cnt","Literal","txt","RESERVEDCHARS_RE","RegExp","encodeNormal","encodeURIComponent","replace","s","escape","encodeReserved","encodeURI","addUnNamed","addNamed","noName","addLabeled","simpleConf","prefix","joiner","encode","builder","reservedConf","fragmentConf","pathParamConf","formParamConf","formContinueConf","pathHierarchyConf","labelConf","Expression","conf","vars","build","ops","nextjoiner","buildSegment","varspec","addValues","segm","UNBOUND","Buffer","limit","str","appender","UnboundAppend","len","BoundAppend","append","part","encoder","substring","arrayToString","arr","maxLength","buffer","objectToString","k","hasOwnProperty","simpleValueHandler","valprops","adder","isArr","isObj","explodeValueHandler","valueProperties","isUndef","constructor","Array","Object","VarSpec","vhfn","nums","unescape","valueHandler","expl","valueModifier","VARSPEC_RE","match2varspec","m","parseInt","LISTSEP","TEMPL_RE","match2expression","expr","match","pushLiteralSubstr","src","from","to","literal","substr","push","parse","lastpos","comp","pattern","lastIndex","exec","newpos","index"],"mappings":"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","sourcesContent":["/*\n UriTemplates Template Processor - Version: @VERSION - Dated: @DATE\n (c) marc.portier@gmail.com - 2011-2012\n Licensed under APLv2 (http://opensource.org/licenses/Apache-2.0)\n */\n\n;\nvar uritemplate = (function() {\n\n// Below are the functions we originally used from jQuery.\n// The implementations below are often more naive then what is inside jquery, but they suffice for our needs.\n\n    function isFunction(fn) {\n        return typeof fn == 'function';\n    }\n\n    function isEmptyObject (obj) {\n        for(var name in obj){\n            return false;\n        }\n        return true;\n    }\n\n    function extend(base, newprops) {\n        for (var name in newprops) {\n            base[name] = newprops[name];\n        }\n        return base;\n    }\n\n    /**\n     * Create a runtime cache around retrieved values from the context.\n     * This allows for dynamic (function) results to be kept the same for multiple\n     * occuring expansions within one template.\n     * Note: Uses key-value tupples to be able to cache null values as well.\n     */\n        //TODO move this into prep-processing\n    function CachingContext(context) {\n        this.raw = context;\n        this.cache = {};\n    }\n    CachingContext.prototype.get = function(key) {\n        var val = this.lookupRaw(key);\n        var result = val;\n\n        if (isFunction(val)) { // check function-result-cache\n            var tupple = this.cache[key];\n            if (tupple !== null && tupple !== undefined) {\n                result = tupple.val;\n            } else {\n                result = val(this.raw);\n                this.cache[key] = {key: key, val: result};\n                // NOTE: by storing tupples we make sure a null return is validly consistent too in expansions\n            }\n        }\n        return result;\n    };\n\n    CachingContext.prototype.lookupRaw = function(key) {\n        return CachingContext.lookup(this, this.raw, key);\n    };\n\n    CachingContext.lookup = function(me, context, key) {\n        var result = context[key];\n        if (result !== undefined) {\n            return result;\n        } else {\n            var keyparts = key.split('.');\n            var i = 0, keysplits = keyparts.length - 1;\n            for (i = 0; i<keysplits; i++) {\n                var leadKey = keyparts.slice(0, keysplits - i).join('.');\n                var trailKey = keyparts.slice(-i-1).join('.');\n                var leadContext = context[leadKey];\n                if (leadContext !== undefined) {\n                    return CachingContext.lookup(me, leadContext, trailKey);\n                }\n            }\n            return undefined;\n        }\n    };\n\n\n    function UriTemplate(set) {\n        this.set = set;\n    }\n\n    UriTemplate.prototype.expand = function(context) {\n        var cache = new CachingContext(context);\n        var res = \"\";\n        var i = 0, cnt = this.set.length;\n        for (i = 0; i<cnt; i++ ) {\n            res += this.set[i].expand(cache);\n        }\n        return res;\n    };\n\n//TODO: change since draft-0.6 about characters in literals\n    /* extract:\n     The characters outside of expressions in a URI Template string are intended to be copied literally to the URI-reference if the character is allowed in a URI (reserved / unreserved / pct-encoded) or, if not allowed, copied to the URI-reference in its UTF-8 pct-encoded form.\n     */\n    function Literal(txt ) {\n        this.txt = txt;\n    }\n\n    Literal.prototype.expand = function() {\n        return this.txt;\n    };\n\n\n\n    var RESERVEDCHARS_RE = new RegExp(\"[:/?#\\\\[\\\\]@!$&()*+,;=']\",\"g\");\n    function encodeNormal(val) {\n        return encodeURIComponent(val).replace(RESERVEDCHARS_RE, function(s) {return escape(s);} );\n    }\n\n//var SELECTEDCHARS_RE = new RegExp(\"[]\",\"g\");\n    function encodeReserved(val) {\n        //return encodeURI(val).replace(SELECTEDCHARS_RE, function(s) {return escape(s)} );\n        return encodeURI(val); // no need for additional replace if selected-chars is empty\n    }\n\n\n    function addUnNamed(name, key, val) {\n        return key + (key.length > 0 ? \"=\" : \"\") + val;\n    }\n\n    function addNamed(name, key, val, noName) {\n        noName = noName || false;\n        if (noName) { name = \"\"; }\n\n        if (!key || key.length === 0)  {\n            key = name;\n        }\n        return key + (key.length > 0 ? \"=\" : \"\") + val;\n    }\n\n    function addLabeled(name, key, val, noName) {\n        noName = noName || false;\n        if (noName) { name = \"\"; }\n\n        if (!key || key.length === 0)  {\n            key = name;\n        }\n        return key + (key.length > 0 && val ? \"=\" : \"\") + val;\n    }\n\n\n    var simpleConf = {\n        prefix : \"\",     joiner : \",\",     encode : encodeNormal,    builder : addUnNamed\n    };\n    var reservedConf = {\n        prefix : \"\",     joiner : \",\",     encode : encodeReserved,  builder : addUnNamed\n    };\n    var fragmentConf = {\n        prefix : \"#\",    joiner : \",\",     encode : encodeReserved,  builder : addUnNamed\n    };\n    var pathParamConf = {\n        prefix : \";\",    joiner : \";\",     encode : encodeNormal,    builder : addLabeled\n    };\n    var formParamConf = {\n        prefix : \"?\",    joiner : \"&\",     encode : encodeNormal,    builder : addNamed\n    };\n    var formContinueConf = {\n        prefix : \"&\",    joiner : \"&\",     encode : encodeNormal,    builder : addNamed\n    };\n    var pathHierarchyConf = {\n        prefix : \"/\",    joiner : \"/\",     encode : encodeNormal,    builder : addUnNamed\n    };\n    var labelConf = {\n        prefix : \".\",    joiner : \".\",     encode : encodeNormal,    builder : addUnNamed\n    };\n\n\n    function Expression(conf, vars ) {\n        extend(this, conf);\n        this.vars = vars;\n    }\n\n    Expression.build = function(ops, vars) {\n        var conf;\n        switch(ops) {\n            case ''  : conf = simpleConf; break;\n            case '+' : conf = reservedConf; break;\n            case '#' : conf = fragmentConf; break;\n            case ';' : conf = pathParamConf; break;\n            case '?' : conf = formParamConf; break;\n            case '&' : conf = formContinueConf; break;\n            case '/' : conf = pathHierarchyConf; break;\n            case '.' : conf = labelConf; break;\n            default  : throw \"Unexpected operator: '\"+ops+\"'\";\n        }\n        return new Expression(conf, vars);\n    };\n\n    Expression.prototype.expand = function(context) {\n        var joiner = this.prefix;\n        var nextjoiner = this.joiner;\n        var buildSegment = this.builder;\n        var res = \"\";\n        var i = 0, cnt = this.vars.length;\n\n        for (i = 0 ; i< cnt; i++) {\n            var varspec = this.vars[i];\n            varspec.addValues(context, this.encode, function(key, val, noName) {\n                var segm = buildSegment(varspec.name, key, val, noName);\n                if (segm !== null && segm !== undefined) {\n                    res += joiner + segm;\n                    joiner = nextjoiner;\n                }\n            });\n        }\n        return res;\n    };\n\n\n\n    var UNBOUND = {};\n\n    /**\n     * Helper class to help grow a string of (possibly encoded) parts until limit is reached\n     */\n    function Buffer(limit) {\n        this.str = \"\";\n        if (limit === UNBOUND) {\n            this.appender = Buffer.UnboundAppend;\n        } else {\n            this.len = 0;\n            this.limit = limit;\n            this.appender = Buffer.BoundAppend;\n        }\n    }\n\n    Buffer.prototype.append = function(part, encoder) {\n        return this.appender(this, part, encoder);\n    };\n\n    Buffer.UnboundAppend = function(me, part, encoder) {\n        part = encoder ? encoder(part) : part;\n        me.str += part;\n        return me;\n    };\n\n    Buffer.BoundAppend = function(me, part, encoder) {\n        part = part.substring(0, me.limit - me.len);\n        me.len += part.length;\n\n        part = encoder ? encoder(part) : part;\n        me.str += part;\n        return me;\n    };\n\n\n    function arrayToString(arr, encoder, maxLength) {\n        var buffer = new Buffer(maxLength);\n        var joiner = \"\";\n\n        var i = 0, cnt = arr.length;\n        for (i=0; i<cnt; i++) {\n            if (arr[i] !== null && arr[i] !== undefined) {\n                buffer.append(joiner).append(arr[i], encoder);\n                joiner = \",\";\n            }\n        }\n        return buffer.str;\n    }\n\n    function objectToString(obj, encoder, maxLength) {\n        var buffer = new Buffer(maxLength);\n        var joiner = \"\";\n        var k;\n\n        for (k in obj) {\n            if (obj.hasOwnProperty(k) ) {\n                if (obj[k] !== null && obj[k] !== undefined) {\n                    buffer.append(joiner + k + ',').append(obj[k], encoder);\n                    joiner = \",\";\n                }\n            }\n        }\n        return buffer.str;\n    }\n\n\n    function simpleValueHandler(me, val, valprops, encoder, adder) {\n        var result;\n\n        if (valprops.isArr) {\n            result = arrayToString(val, encoder, me.maxLength);\n        } else if (valprops.isObj) {\n            result = objectToString(val, encoder, me.maxLength);\n        } else {\n            var buffer = new Buffer(me.maxLength);\n            result = buffer.append(val, encoder).str;\n        }\n\n        adder(\"\", result);\n    }\n\n    function explodeValueHandler(me, val, valprops, encoder, adder) {\n        if (valprops.isArr) {\n            var i = 0, cnt = val.length;\n            for (i = 0; i<cnt; i++) {\n                adder(\"\", encoder(val[i]) );\n            }\n        } else if (valprops.isObj) {\n            var k;\n            for (k in val) {\n                if (val.hasOwnProperty(k)) {\n                    adder(k, encoder(val[k]) );\n                }\n            }\n        } else { // explode-requested, but single value\n            adder(\"\", encoder(val));\n        }\n    }\n\n    function valueProperties(val) {\n        var isArr = false;\n        var isObj = false;\n        var isUndef = true;  //note: \"\" is empty but not undef\n\n        if (val !== null && val !== undefined) {\n            isArr = (val.constructor === Array);\n            isObj = (val.constructor === Object);\n            isUndef = (isArr && val.length === 0) || (isObj && isEmptyObject(val));\n        }\n\n        return {isArr: isArr, isObj: isObj, isUndef: isUndef};\n    }\n\n\n    function VarSpec (name, vhfn, nums) {\n        this.name = unescape(name);\n        this.valueHandler = vhfn;\n        this.maxLength = nums;\n    }\n\n\n    VarSpec.build = function(name, expl, part, nums) {\n        var valueHandler, valueModifier;\n\n        if (!!expl) { //interprete as boolean\n            valueHandler = explodeValueHandler;\n        } else {\n            valueHandler = simpleValueHandler;\n        }\n\n        if (!part) {\n            nums = UNBOUND;\n        }\n\n        return new VarSpec(name, valueHandler, nums);\n    };\n\n\n    VarSpec.prototype.addValues = function(context, encoder, adder) {\n        var val = context.get(this.name);\n        var valprops = valueProperties(val);\n        if (valprops.isUndef) { return; } // ignore empty values\n        this.valueHandler(this, val, valprops, encoder, adder);\n    };\n\n\n\n//----------------------------------------------parsing logic\n// How each varspec should look like\n    var VARSPEC_RE=/([^*:]*)((\\*)|(:)([0-9]+))?/;\n\n    var match2varspec = function(m) {\n        var name = m[1];\n        var expl = m[3];\n        var part = m[4];\n        var nums = parseInt(m[5], 10);\n\n        return VarSpec.build(name, expl, part, nums);\n    };\n\n\n// Splitting varspecs in list with:\n    var LISTSEP=\",\";\n\n// How each template should look like\n    var TEMPL_RE=/(\\{([+#.;?&\\/])?(([^.*:,{}|@!=$()][^*:,{}$()]*)(\\*|:([0-9]+))?(,([^.*:,{}][^*:,{}]*)(\\*|:([0-9]+))?)*)\\})/g;\n// Note: reserved operators: |!@ are left out of the regexp in order to make those templates degrade into literals\n// (as expected by the spec - see tests.html \"reserved operators\")\n\n\n    var match2expression = function(m) {\n        var expr = m[0];\n        var ops = m[2] || '';\n        var vars = m[3].split(LISTSEP);\n        var i = 0, len = vars.length;\n        for (i = 0; i<len; i++) {\n            var match;\n            if ( (match = vars[i].match(VARSPEC_RE)) === null) {\n                throw \"unexpected parse error in varspec: \" + vars[i];\n            }\n            vars[i] = match2varspec(match);\n        }\n\n        return Expression.build(ops, vars);\n    };\n\n\n    var pushLiteralSubstr = function(set, src, from, to) {\n        if (from < to) {\n            var literal = src.substr(from, to - from);\n            set.push(new Literal(literal));\n        }\n    };\n\n    var parse = function(str) {\n        var lastpos = 0;\n        var comp = [];\n\n        var match;\n        var pattern = TEMPL_RE;\n        pattern.lastIndex = 0; // just to be sure\n        while ((match = pattern.exec(str)) !== null) {\n            var newpos = match.index;\n            pushLiteralSubstr(comp, str, lastpos, newpos);\n\n            comp.push(match2expression(match));\n            lastpos = pattern.lastIndex;\n        }\n        pushLiteralSubstr(comp, str, lastpos, str.length);\n\n        return new UriTemplate(comp);\n    };\n\n\n//-------------------------------------------comments and ideas\n\n//TODO: consider building cache of previously parsed uris or even parsed expressions?\n\n    return parse;\n\n}());\n"]},"metadata":{},"sourceType":"module"}